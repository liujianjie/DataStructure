#include <iostream>
#include "Quote.h"
#include "Bulk_quote.h"
#include "Partice157.h"
#include "Disc_quote.h"

using namespace std;

/*
引出：
继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数,这样我们才能动态分配继承体系中的对象了。

delete一个动态分配的对象的指针时执行析构函数。
但静态类型与动态类型不符，如：删除一个父类的指针，而实际上动态类型是指向子类，则需要执行动态类型的子类的析构函数，所以需要把析构函数定义成虚函数

1.只要基类定义了虚析构函数，则派生类的析构函数是合成的还是自己定义的，都将是虚的

note：若基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为
如果一个类需要析构函数，则同样需要拷贝和赋值操作，但是基类的析构函数是例外。
一个基类总需要析构函数，而且它能将析构函数设定为虚函数，此时，该析构函数为了成为虚函数而内容为空，显然无法推断是否需要拷贝和赋值

二、虚析构函数将阻止合成移动操作
一个类定义了析构函数，即使是=default的合成版，编译器也不会为这个类合成移动操作

*/
class Quote {
public:
	virtual ~Quote() = default;
};
int main()
{
	int a;



	// 练习
	/*
	15.24：具有动态分配的成员的继承体系中的基类需要，执行删除 动态分配的成员
	*/
	cin >> a;
	return 0;
}
